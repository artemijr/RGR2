import numpy as np


# Функция подынтегрального выражения в полярных координатах
# Это функция, которая будет интегрироваться для нахождения объема.
# Принимает радиус (r) и угол (theta) и возвращает значение подынтегральной функции.
def integrand(r, theta):
    # Умножаем на 'r' потому что в полярных координатах элемент площади dA = r * dr * dtheta
    return r * (8 - (r * np.sin(theta)) ** 2)


# Метод трапеций для численного интегрирования в двух измерениях
# Функция принимает функцию для интегрирования, пределы интегрирования по r и theta,
# а также количество точек для разбиения области интегрирования по каждому измерению.

def trapezoidal_rule_2d(func, r_lim, theta_lim, num_points_r, num_points_theta):
    # Создаем равномерно распределенные точки для r и theta в их диапазонах.
    r = np.linspace(r_lim[0], r_lim[1], num_points_r)
    theta = np.linspace(theta_lim[0], theta_lim[1], num_points_theta)

    # Вычисляем шаги сетки (dr и dtheta) как расстояние между точками.
    dr = (r_lim[1] - r_lim[0]) / (num_points_r - 1)
    dtheta = (theta_lim[1] - theta_lim[0]) / (num_points_theta - 1)

    # Инициализируем переменную для суммы площадей трапеций.
    integral = 0
    # Двойной цикл для прохождения по сетке и вычисления площади каждой трапеции.
    for i in range(num_points_r - 1):
        for j in range(num_points_theta - 1):
            # Среднее значение функции на четырех углах трапеции
            # Это приближение функции внутри малого элемента области.
            f_avg = (func(r[i], theta[j]) + func(r[i + 1], theta[j]) +
                     func(r[i], theta[j + 1]) + func(r[i + 1], theta[j + 1])) / 4
            # Добавляем площадь текущей трапеции к общей сумме
            # Произведение dA = dr * dtheta дает площадь малого элемента,
            # умножение на f_avg дает объем над этим элементом.
            integral += f_avg * dr * dtheta

    return integral


# Точка входа в программу.
if __name__ == "__main__":
    # Определение пределов интегрирования для переменных r и theta.
    theta_lim = (0, 2 * np.pi)  # Угол theta охватывает полный круг от 0 до 2*pi.
    r_lim = (0, 2)  # Радиус r изменяется от 0 до 2, что соответствует радиусу основания цилиндра.

    # Вызов функции для вычисления объема с использованием метода трапеций.
    # Количество точек по каждой оси задается равным 100 для достижения приемлемой точности.
    volume = trapezoidal_rule_2d(integrand, r_lim, theta_lim, 1000, 1000)

    # Вывод результата вычисления.
    print(f"Объем тела примерно равен {volume:.3f} кубических единиц.")



'''
Мы используем полярные координаты, так как они упрощают интегрирование по круговой области.
Подынтегральная функция умножается на r, так как в полярных координатах элемент площади dA 
не является просто dr * dtheta; нужно учитывать радиальное расширение при увеличении радиуса, 
то есть dA = r * dr * dtheta.
Метод трапеций применяется путем разбиения области интегрирования на маленькие сегменты и 
аппроксимации площади под функцией как суммы площадей трапеций, образованных этими сегментами.
Двойное интегрирование означает, что мы интегрируем как по радиусу, так и по углу, чтобы получить объем.
'''